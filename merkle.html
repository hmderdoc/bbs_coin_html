<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>BBS Coin - Epoch Publisher</title>

  <script src="https://cdn.jsdelivr.net/npm/ethers@6.13.5/dist/ethers.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <style>
    :root {
      --bg: #0c0c0c;
      --card: #111318;
      --border: #0cc;
      --border-dim: #066;
      --cyan: #0ff;
      --cyan-dim: #099;
      --gold: #ffd700;
      --green: #0f0;
      --green-dim: #090;
      --red: #f44;
      --red-dim: #a22;
      --white: #eee;
      --gray: #888;
      --text: #ccc;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: var(--bg);
      color: var(--text);
      font-family: 'IBM Plex Mono', 'Cascadia Code', 'Fira Code', 'Courier New', monospace;
      font-size: 14px;
      line-height: 1.6;
      padding: 20px;
    }
    .container { max-width: 900px; margin: 0 auto; }
    header {
      text-align: center;
      padding: 24px 0;
      border: 1px solid var(--border);
      background: var(--card);
      margin-bottom: 2px;
    }
    header h1 {
      color: var(--gold);
      font-size: 22px;
      font-weight: bold;
      letter-spacing: 2px;
    }
    header .subtitle { color: var(--cyan-dim); font-size: 12px; margin-top: 4px; }
    section {
      border: 1px solid var(--border-dim);
      background: var(--card);
      padding: 20px;
      margin-bottom: 2px;
    }
    section h2 {
      color: var(--cyan);
      font-size: 14px;
      font-weight: bold;
      letter-spacing: 1px;
      margin-bottom: 16px;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--border-dim);
    }
    label { color: var(--gray); font-size: 12px; display: block; margin-bottom: 4px; }
    input[type="text"], input[type="number"], textarea, select {
      background: #0a0a0a;
      border: 1px solid var(--border-dim);
      color: var(--white);
      font-family: inherit;
      font-size: 13px;
      padding: 8px 10px;
      width: 100%;
      outline: none;
    }
    input:focus, textarea:focus, select:focus { border-color: var(--cyan); }
    textarea { min-height: 120px; resize: vertical; }
    .row { display: flex; gap: 12px; align-items: flex-end; margin-bottom: 12px; flex-wrap: wrap; }
    .row .field { flex: 1; }
    .row .field-sm { flex: 0 0 160px; }
    button {
      background: transparent;
      border: 1px solid var(--cyan);
      color: var(--cyan);
      font-family: inherit;
      font-size: 13px;
      padding: 8px 20px;
      cursor: pointer;
      letter-spacing: 0.5px;
      transition: all 0.15s;
    }
    button:hover:not(:disabled) { background: var(--cyan); color: var(--bg); }
    button:disabled { border-color: var(--border-dim); color: var(--gray); cursor: not-allowed; }
    button.primary { border-color: var(--gold); color: var(--gold); }
    button.primary:hover:not(:disabled) { background: var(--gold); color: var(--bg); }
    button.download { border-color: var(--green-dim); color: var(--green); font-size: 12px; padding: 6px 14px; }
    button.download:hover:not(:disabled) { background: var(--green); color: var(--bg); }

    .status-line { font-size: 12px; margin: 4px 0; }
    .status-line .label { color: var(--gray); display: inline; }
    .status-line .value { color: var(--white); }
    .ok { color: var(--green); }
    .warn { color: var(--gold); }
    .err { color: var(--red); }
    .dim { color: var(--gray); }
    .mono { font-family: inherit; word-break: break-all; }
    .msg-box { padding: 10px 14px; margin: 10px 0; font-size: 12px; border-left: 3px solid; }
    .msg-box.error { border-color: var(--red); background: rgba(255,68,68,0.08); color: var(--red); }
    .msg-box.success { border-color: var(--green); background: rgba(0,255,0,0.06); color: var(--green); }
    .msg-box.info { border-color: var(--cyan); background: rgba(0,204,204,0.06); color: var(--cyan-dim); }
    .msg-box.warning { border-color: var(--gold); background: rgba(255,215,0,0.06); color: var(--gold); }

    table { width: 100%; border-collapse: collapse; font-size: 12px; margin: 10px 0; }
    th { color: var(--gold); text-align: left; padding: 6px 8px; border-bottom: 1px solid var(--border-dim); font-weight: normal; letter-spacing: 0.5px; }
    td { padding: 4px 8px; border-bottom: 1px solid #1a1a1a; color: var(--text); }
    td.addr { font-size: 11px; color: var(--cyan-dim); }
    td.num { text-align: right; color: var(--green); }
    .summary { display: flex; gap: 24px; margin: 10px 0; font-size: 13px; flex-wrap: wrap; }
    .summary .item .label { display: inline; color: var(--gray); }
    .summary .item .value { color: var(--gold); font-weight: bold; }
    .root-display {
      background: #0a0a0a;
      border: 1px solid var(--border-dim);
      padding: 10px;
      margin: 10px 0;
      font-size: 11px;
      word-break: break-all;
      color: var(--cyan);
    }
    .root-display .label { color: var(--gray); margin-bottom: 4px; }
    .btn-row { display: flex; gap: 10px; margin: 12px 0; flex-wrap: wrap; }
    .hidden { display: none !important; }
    .tx-link { color: var(--cyan); text-decoration: none; }
    .tx-link:hover { text-decoration: underline; }
    .safety-checks .check { font-size: 12px; margin: 4px 0; }
    .spinner {
      display: inline-block;
      width: 12px;
      height: 12px;
      border: 2px solid var(--border-dim);
      border-top-color: var(--cyan);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin-right: 6px;
      vertical-align: middle;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .example-link { color: var(--cyan-dim); font-size: 11px; cursor: pointer; text-decoration: underline; }
    .example-link:hover { color: var(--cyan); }
    footer {
      text-align: center;
      padding: 16px;
      font-size: 11px;
      color: var(--gray);
      border: 1px solid var(--border-dim);
      background: var(--card);
    }
    footer a { color: var(--cyan-dim); text-decoration: none; }
    footer a:hover { color: var(--cyan); }
    .help { font-size: 12px; color: var(--gray); }
    .hr { height: 1px; background: #1a1a1a; margin: 12px 0; }
    .small { font-size: 12px; }
    pre.preview {
      background: #0a0a0a;
      border: 1px solid var(--border-dim);
      padding: 10px;
      font-size: 12px;
      white-space: pre-wrap;
      word-break: break-word;
      color: var(--white);
      max-height: 240px;
      overflow: auto;
    }
  </style>
</head>

<body>
<div class="container">

  <header>
    <h1>BBS COIN EPOCH PUBLISHER</h1>
    <div class="subtitle">Build and publish Merkle distribution epochs on-chain</div>
  </header>

  <!-- ============================================================ -->
  <!-- SETUP -->
  <!-- ============================================================ -->
  <section id="sec-setup">
    <h2>SETUP</h2>
    <div class="row">
      <div class="field">
        <label>Distributor Contract Address</label>
        <input type="text" id="contractAddr" placeholder="0x..." />
      </div>
      <div class="field-sm">
        <label>Token Decimals</label>
        <input type="number" id="tokenDecimals" value="18" min="0" max="18" />
      </div>
      <div class="field-sm">
        <label>Claim page base URL</label>
        <input type="text" id="claimBaseUrl" value="https://hmderdoc.github.io/bbs_coin_html/tx.html" />
      </div>
    </div>
    <div class="btn-row">
      <button id="btnConnect" onclick="connectWallet()">Connect Wallet</button>
    </div>
    <div id="setupStatus"></div>
  </section>

  <!-- ============================================================ -->
  <!-- DISTRIBUTION DATA -->
  <!-- ============================================================ -->
  <section id="sec-input">
    <h2>DISTRIBUTION DATA</h2>
    <label>
      Paste JSON array — <span class="example-link" onclick="loadExample()">load example</span>
    </label>
    <textarea id="inputData" placeholder='[{"address": "0x...", "tokens": 10, "email":"user@example.com"}, {"address":"0x...","tokens":20}]'></textarea>
    <div class="btn-row">
      <button id="btnBuild" onclick="parseAndBuild()" disabled>Parse &amp; Build Merkle Tree</button>
    </div>
    <div id="buildStatus"></div>

    <div id="buildResults" class="hidden">
      <table>
        <thead>
          <tr><th>#</th><th>Address</th><th>Tokens</th><th>Amount (base units)</th><th>Email (optional)</th></tr>
        </thead>
        <tbody id="resultsBody"></tbody>
      </table>

      <div class="summary">
        <div class="item"><span class="label">Total: </span><span class="value" id="totalTokens"></span></div>
        <div class="item"><span class="label">Recipients: </span><span class="value" id="recipientCount"></span></div>
        <div class="item"><span class="label">Emails: </span><span class="value" id="emailCount"></span></div>
      </div>

      <div class="root-display">
        <div class="label">Merkle Root</div>
        <div id="merkleRootDisplay"></div>
      </div>
      <div class="root-display">
        <div class="label">Epoch URI</div>
        <div id="epochUriDisplay"></div>
      </div>

      <div id="safetyChecks" class="safety-checks"></div>
    </div>
  </section>

  <!-- ============================================================ -->
  <!-- PUBLISH -->
  <!-- ============================================================ -->
  <section id="sec-publish">
    <h2>PUBLISH EPOCH</h2>
    <div class="btn-row">
      <button id="btnPublish" class="primary" onclick="publishEpoch()" disabled>Publish Epoch to Blockchain</button>
    </div>
    <div id="publishStatus"></div>
  </section>

  <!-- ============================================================ -->
  <!-- DOWNLOAD -->
  <!-- ============================================================ -->
  <section id="sec-download">
    <h2>DOWNLOAD ARTIFACTS</h2>
    <p class="dim small" style="margin-bottom:10px">
      These files are required for proof verification and user claim generation.
      After a successful publish, <span class="mono" id="zipAutoText">the ZIP will be downloaded automatically.</span>
    </p>

    <div class="btn-row">
      <button class="download" id="btnDlZip" onclick="downloadZip(false)" disabled>Download as .zip</button>
      <button class="download" id="btnDlProofs" onclick="downloadProofs()" disabled>proofs.json</button>
      <button class="download" id="btnDlEpoch" onclick="downloadEpochJson()" disabled>epoch.json</button>
      <button class="download" id="btnDlRoot" onclick="downloadRoot()" disabled>root.json</button>
    </div>

    <div id="downloadStatus"></div>
  </section>

  <!-- ============================================================ -->
  <!-- NOTIFY USERS (separate concern; appears after publish) -->
  <!-- ============================================================ -->
  <section id="sec-notify" class="hidden">
    <h2>NOTIFY USERS (OPTIONAL)</h2>

    <div class="msg-box info">
      Email addresses are <b>not</b> part of the Merkle tree. This step is purely operational for sysops.
    </div>

    <div class="row">
      <div class="field">
        <label>Email “From” / signature line</label>
        <input id="notifyFromLine" type="text" placeholder="-- futureland.today" />
      </div>
      <div class="field-sm">
        <label>Token symbol (display)</label>
        <input id="notifyTokenSymbol" type="text" value="BBS" />
      </div>
      <div class="field-sm">
        <label>Token name (display)</label>
        <input id="notifyTokenName" type="text" value="BBS Token" />
      </div>
    </div>

    <div class="btn-row">
      <button class="download" id="btnGenEmails" onclick="generateEmails()">Generate email previews</button>
      <button class="download" id="btnDlNotifyZip" onclick="downloadNotificationsZip()" disabled>Download notifications .zip</button>
    </div>

    <div class="hr"></div>

    <div class="row">
      <div class="field">
        <label>EmailJS (optional): public key</label>
        <input id="emailjsPublicKey" type="text" placeholder="EmailJS public key (client-side)" />
      </div>
      <div class="field">
        <label>EmailJS: serviceId</label>
        <input id="emailjsServiceId" type="text" placeholder="service_xxx" />
      </div>
      <div class="field">
        <label>EmailJS: templateId</label>
        <input id="emailjsTemplateId" type="text" placeholder="template_xxx" />
      </div>
    </div>

    <div class="help">
      If you use EmailJS, you must create a template that accepts variables:
      <span class="mono">to_email</span>, <span class="mono">subject</span>, <span class="mono">message</span>.
      Free plan is listed as “200 monthly requests.”  [oai_citation:1‡EmailJS](https://www.emailjs.com/pricing/?utm_source=chatgpt.com)
    </div>

    <div class="btn-row">
      <button id="btnSendEmailjs" class="primary" onclick="sendViaEmailJS()" disabled>Send emails via EmailJS</button>
    </div>

    <div class="hr"></div>

    <label>Preview (first email with an address)</label>
    <pre class="preview" id="emailPreview">(generate to preview)</pre>

    <div id="notifyStatus"></div>
  </section>

  <footer>
    BBS Coin — A multi-sig community project. Tokens carry no implied value.
    • <a href="https://polygonscan.com" target="_blank">PolygonScan</a>
  </footer>

</div>

<script>
/* ========================================================================
   ABI
   ======================================================================== */
const DISTRIBUTOR_ABI = [
  "function currentEpoch() view returns (uint256)",
  "function publishEpoch(bytes32 root, string uri)",
  "function owner() view returns (address)",
  "function epochRoot(uint256 epoch) view returns (bytes32)",
  "function epochURI(uint256 epoch) view returns (string)",
  "function isClaimed(uint256 epoch, address account) view returns (bool)",
  "function paused() view returns (bool)",
  "event EpochPublished(uint256 indexed epoch, bytes32 root, string uri)"
];

const DEFAULT_CONTRACT = "0x0AA6b0A320831Df4A14bd846Fc999B97dDdEe782";
const POLYGON_CHAIN_ID = 137;

/* ========================================================================
   STATE
   ======================================================================== */
let state = {
  provider: null,
  signer: null,
  contract: null,
  connectedAddress: null,
  chainId: null,
  currentEpoch: null,
  ownerAddress: null,
  isPaused: false,

  // normalized entries: { address, tokensStr, tokensWei, email? }
  entries: null,
  leafHashes: null,
  layers: null,
  merkleRoot: null,
  epochUri: null,

  txHash: null,
  publishedEpochId: null,

  // artifacts cache
  artifacts: {
    proofs: null,
    epoch: null,
    root: null
  },

  // notify cache
  notifications: null // array of {address,email,subject,body,filename}
};

/* ========================================================================
   INIT
   ======================================================================== */
(function init() {
  const saved = localStorage.getItem("bbscoin_contract");
  const savedDec = localStorage.getItem("bbscoin_decimals");
  const savedClaim = localStorage.getItem("bbscoin_claim_base");

  document.getElementById("contractAddr").value = saved || DEFAULT_CONTRACT;
  if (savedDec) document.getElementById("tokenDecimals").value = savedDec;
  if (savedClaim) document.getElementById("claimBaseUrl").value = savedClaim;

  document.getElementById("contractAddr").addEventListener("change", function() {
    localStorage.setItem("bbscoin_contract", this.value.trim());
  });
  document.getElementById("tokenDecimals").addEventListener("change", function() {
    localStorage.setItem("bbscoin_decimals", this.value);
  });
  document.getElementById("claimBaseUrl").addEventListener("change", function() {
    localStorage.setItem("bbscoin_claim_base", this.value.trim());
  });
})();

/* ========================================================================
   MERKLE TREE — matches contract leaf encoding exactly
   leaf = keccak256(abi.encodePacked(address, uint256))
   pair = OZ sorted pair hash
   ======================================================================== */
function hashLeaf(address, amountWei) {
  return ethers.keccak256(
    ethers.solidityPacked(["address", "uint256"], [address, amountWei])
  );
}
function hashPair(a, b) {
  const aNorm = a.toLowerCase();
  const bNorm = b.toLowerCase();
  const [left, right] = aNorm < bNorm ? [a, b] : [b, a];
  return ethers.keccak256(
    ethers.solidityPacked(["bytes32", "bytes32"], [left, right])
  );
}
function buildMerkleTree(leaves) {
  if (leaves.length === 0) throw new Error("Cannot build tree with zero leaves");
  if (leaves.length === 1) return { root: leaves[0], layers: [leaves] };

  const layers = [leaves.slice()];
  while (layers[layers.length - 1].length > 1) {
    const prev = layers[layers.length - 1];
    const next = [];
    for (let i = 0; i < prev.length; i += 2) {
      const left = prev[i];
      const right = (i + 1 < prev.length) ? prev[i + 1] : prev[i];
      next.push(hashPair(left, right));
    }
    layers.push(next);
  }
  return { root: layers[layers.length - 1][0], layers };
}
function getProof(layers, leafIndex) {
  const proof = [];
  let idx = leafIndex;
  for (let i = 0; i < layers.length - 1; i++) {
    const layer = layers[i];
    let siblingIdx = (idx % 2 === 0) ? idx + 1 : idx - 1;
    if (siblingIdx >= layer.length) proof.push(layer[idx]);
    else proof.push(layer[siblingIdx]);
    idx = Math.floor(idx / 2);
  }
  return proof;
}
function verifyProof(proof, root, leaf) {
  let hash = leaf;
  for (const p of proof) hash = hashPair(hash, p);
  return hash.toLowerCase() === root.toLowerCase();
}

/* ========================================================================
   WALLET & CONTRACT
   ======================================================================== */
async function connectWallet() {
  const statusEl = document.getElementById("setupStatus");
  statusEl.innerHTML = '<div class="msg-box info"><span class="spinner"></span>Connecting wallet...</div>';

  try {
    if (!window.ethereum) {
      throw new Error("No wallet detected. Install MetaMask or a compatible browser wallet.");
    }

    const provider = new ethers.BrowserProvider(window.ethereum);
    await provider.send("eth_requestAccounts", []);
    const signer = await provider.getSigner();
    const address = await signer.getAddress();
    const network = await provider.getNetwork();

    state.provider = provider;
    state.signer = signer;
    state.connectedAddress = address;
    state.chainId = Number(network.chainId);

    const contractAddr = document.getElementById("contractAddr").value.trim();
    if (!ethers.isAddress(contractAddr)) throw new Error("Invalid contract address");

    const contract = new ethers.Contract(contractAddr, DISTRIBUTOR_ABI, signer);
    state.contract = contract;

    const [currentEpoch, owner, paused] = await Promise.all([
      contract.currentEpoch(),
      contract.owner(),
      contract.paused().catch(() => false)
    ]);

    state.currentEpoch = Number(currentEpoch);
    state.ownerAddress = owner;
    state.isPaused = paused;

    const isOwner = address.toLowerCase() === owner.toLowerCase();
    const chainName = state.chainId === POLYGON_CHAIN_ID ? "Polygon" : "Chain " + state.chainId;

    let html = '';
    html += statusLine("Connected", shortAddr(address), "ok");
    html += statusLine("Network", chainName + " (" + state.chainId + ")", state.chainId === POLYGON_CHAIN_ID ? "ok" : "warn");
    html += statusLine("Next Epoch", "#" + state.currentEpoch, "ok");
    html += statusLine("Contract Owner", shortAddr(owner), "");
    html += statusLine("Your Role", isOwner ? "Owner ✓" : "Not owner — cannot publish", isOwner ? "ok" : "err");

    if (state.isPaused) html += '<div class="msg-box warning">Contract is paused. Publishing and claims may be blocked.</div>';

    statusEl.innerHTML = html;

    document.getElementById("btnBuild").disabled = false;
    document.getElementById("btnConnect").textContent = "Reconnect";

  } catch (err) {
    statusEl.innerHTML = '<div class="msg-box error">' + escHtml(err.message) + '</div>';
  }
}

/* ========================================================================
   PARSE & BUILD (supports optional email)
   Input supports keys:
     - address / addr / wallet
     - tokens (human units) OR amount (human units)
     - email (optional)
   ======================================================================== */
async function parseAndBuild() {
  const statusEl = document.getElementById("buildStatus");
  const resultsEl = document.getElementById("buildResults");
  resultsEl.classList.add("hidden");

  try {
    const raw = document.getElementById("inputData").value.trim();
    if (!raw) throw new Error("No input data");

    let entries;
    try { entries = JSON.parse(raw); }
    catch (_) {
      // tolerate JS-ish arrays pasted in
      try { entries = (new Function("return " + raw))(); }
      catch { throw new Error("Invalid JSON. Expected: [{address:\"0x...\", tokens:10, email:\"a@b.com\"}, ...]"); }
    }

    if (!Array.isArray(entries) || entries.length === 0) {
      throw new Error("Input must be a non-empty array");
    }

    const decimals = parseInt(document.getElementById("tokenDecimals").value) || 18;

    const normalized = [];
    const seenAddresses = new Set();

    for (let i = 0; i < entries.length; i++) {
      const e = entries[i] || {};
      const addr = e.address || e.addr || e.wallet;
      const tokens = (e.tokens ?? e.amount ?? e.value);
      const email = (typeof e.email === "string" && e.email.trim()) ? e.email.trim() : null;

      if (!addr || !ethers.isAddress(addr)) throw new Error(`Entry ${i + 1}: invalid address "${addr}"`);
      if (tokens === undefined || tokens === null || Number(tokens) <= 0) throw new Error(`Entry ${i + 1}: invalid token amount ${tokens}`);

      const checksumAddr = ethers.getAddress(addr);
      const addrLower = checksumAddr.toLowerCase();
      if (seenAddresses.has(addrLower)) throw new Error("Duplicate address: " + checksumAddr);
      seenAddresses.add(addrLower);

      const tokensWei = ethers.parseUnits(String(tokens), decimals);

      normalized.push({
        address: checksumAddr,
        tokensStr: String(tokens),
        tokensWei,
        email: email || undefined
      });
    }

    // Safety checks
    const safetyEl = document.getElementById("safetyChecks");
    let safetyHtml = "";

    if (state.ownerAddress) {
      const ownerLower = state.ownerAddress.toLowerCase();
      const ownerInList = normalized.some(x => x.address.toLowerCase() === ownerLower);
      if (ownerInList) {
        safetyHtml += '<div class="check err">✗ CRITICAL: Contract owner is in the distribution list.</div>';
        throw new Error("Safety check failed: contract owner address found in distribution. This can trap tokens.");
      } else {
        safetyHtml += '<div class="check ok">✓ Owner address not in distribution</div>';
      }
    }

    for (const e of normalized) {
      if (e.address === ethers.ZeroAddress) throw new Error("Zero address found in distribution");
    }
    safetyHtml += '<div class="check ok">✓ No zero addresses</div>';

    // Build Merkle tree
    const leafHashes = normalized.map(e => hashLeaf(e.address, e.tokensWei));
    const { root, layers } = buildMerkleTree(leafHashes);

    // Verify all proofs locally
    for (let i = 0; i < leafHashes.length; i++) {
      const proof = getProof(layers, i);
      if (!verifyProof(proof, root, leafHashes[i])) {
        throw new Error("Internal error: proof verification failed (bug).");
      }
    }
    safetyHtml += `<div class="check ok">✓ All proofs verified locally (${normalized.length}/${normalized.length})</div>`;

    // Epoch URI (keep your existing style; change if you want bbscoin://... later)
    const epochUri = "epoch-" + state.currentEpoch;

    // Store state
    state.entries = normalized;
    state.leafHashes = leafHashes;
    state.layers = layers;
    state.merkleRoot = root;
    state.epochUri = epochUri;
    state.txHash = null;
    state.publishedEpochId = null;
    state.artifacts.proofs = null;
    state.artifacts.epoch = null;
    state.artifacts.root = null;
    state.notifications = null;

    // Render results
    const tbody = document.getElementById("resultsBody");
    tbody.innerHTML = normalized.map((e, i) => (
      `<tr>
        <td>${i + 1}</td>
        <td class="addr">${e.address}</td>
        <td class="num">${escHtml(e.tokensStr)}</td>
        <td class="addr">${e.tokensWei.toString()}</td>
        <td class="addr">${e.email ? escHtml(e.email) : '<span class="dim">(none)</span>'}</td>
      </tr>`
    )).join("");

    const totalWei = normalized.reduce((sum, e) => sum + e.tokensWei, 0n);
    const totalTokensDisplay = ethers.formatUnits(totalWei, decimals);

    const emailCount = normalized.filter(x => !!x.email).length;

    document.getElementById("totalTokens").textContent = totalTokensDisplay + " tokens";
    document.getElementById("recipientCount").textContent = normalized.length;
    document.getElementById("emailCount").textContent = emailCount + " provided";
    document.getElementById("merkleRootDisplay").textContent = root;
    document.getElementById("epochUriDisplay").textContent = epochUri;
    safetyEl.innerHTML = safetyHtml;

    resultsEl.classList.remove("hidden");
    statusEl.innerHTML = '<div class="msg-box success">Merkle tree built successfully</div>';

    // Enable publish & downloads
    document.getElementById("btnPublish").disabled = false;

    // enable downloads (they’ll reflect pre/post publish epochId)
    document.getElementById("btnDlZip").disabled = false;
    document.getElementById("btnDlProofs").disabled = false;
    document.getElementById("btnDlEpoch").disabled = false;
    document.getElementById("btnDlRoot").disabled = false;

    // hide notify until publish
    document.getElementById("sec-notify").classList.add("hidden");

  } catch (err) {
    statusEl.innerHTML = '<div class="msg-box error">' + escHtml(err.message) + '</div>';
  }
}

/* ========================================================================
   PUBLISH (auto-download zip on confirmation)
   ======================================================================== */
async function publishEpoch() {
  const statusEl = document.getElementById("publishStatus");
  const dlStatus = document.getElementById("downloadStatus");

  try {
    if (!state.contract || !state.merkleRoot) throw new Error("Build the Merkle tree first");
    if (!state.signer) throw new Error("Wallet not connected");

    const proceed = confirm(
      `Publish epoch #${state.currentEpoch}?\n\n` +
      `Root: ${state.merkleRoot.substring(0, 18)}...\n` +
      `URI: ${state.epochUri}\n` +
      `Recipients: ${state.entries.length}\n\n` +
      `This is an on-chain transaction and cannot be undone.`
    );
    if (!proceed) return;

    statusEl.innerHTML = '<div class="msg-box info"><span class="spinner"></span>Sending transaction... Sign in your wallet.</div>';

    const liveEpoch = Number(await state.contract.currentEpoch());
    if (liveEpoch !== state.currentEpoch) {
      throw new Error(`Epoch mismatch! Expected #${state.currentEpoch} but contract says #${liveEpoch}. Refresh and rebuild.`);
    }

    const tx = await state.contract.publishEpoch(state.merkleRoot, state.epochUri);
    state.txHash = tx.hash;

    statusEl.innerHTML =
      `<div class="msg-box info"><span class="spinner"></span>Transaction sent. Waiting for confirmation...<br>` +
      `<span class="dim">TX: ${escHtml(tx.hash)}</span></div>`;

    const receipt = await tx.wait();

    // Parse EpochPublished event
    let publishedId = state.currentEpoch;
    const iface = new ethers.Interface(DISTRIBUTOR_ABI);
    for (const log of receipt.logs) {
      try {
        const parsed = iface.parseLog({ topics: log.topics, data: log.data });
        if (parsed && parsed.name === "EpochPublished") {
          publishedId = Number(parsed.args[0]);
          break;
        }
      } catch (_) {}
    }
    state.publishedEpochId = publishedId;

    const explorerUrl = (state.chainId === POLYGON_CHAIN_ID)
      ? ("https://polygonscan.com/tx/" + tx.hash)
      : "#";

    statusEl.innerHTML =
      `<div class="msg-box success">✓ Epoch #${publishedId} published successfully!<br>` +
      `<a class="tx-link" href="${explorerUrl}" target="_blank">${escHtml(tx.hash.substring(0, 22) + "...")}</a>` +
      ` &bull; View on explorer</div>`;

    document.getElementById("btnPublish").disabled = true;
    document.getElementById("btnPublish").textContent = "Published ✓";

    // Refresh next epoch
    state.currentEpoch = Number(await state.contract.currentEpoch());

    // Auto-download ZIP (blockchain artifacts only)
    dlStatus.innerHTML =
      `<div class="msg-box info"><span class="spinner"></span>Auto-downloading artifacts ZIP...</div>`;

    await downloadZip(true);

    dlStatus.innerHTML =
      `<div class="msg-box success">✓ Artifacts saved. ZIP auto-downloaded for epoch #${publishedId}.</div>`;

    // Show notify section after publish
    document.getElementById("sec-notify").classList.remove("hidden");
    updateEmailjsButtonState();

  } catch (err) {
    let msg = err.message;
    if (err.reason) msg = err.reason;
    if (err.data && err.data.message) msg = err.data.message;
    statusEl.innerHTML = '<div class="msg-box error">' + escHtml(msg) + '</div>';
  }
}

/* ========================================================================
   ARTIFACT BUILDERS
   ======================================================================== */
function epochIdForFiles() {
  return (state.publishedEpochId !== null && state.publishedEpochId !== undefined)
    ? state.publishedEpochId
    : state.currentEpoch;
}

function buildProofsArtifact() {
  if (!state.entries || !state.layers) return null;
  const proofs = {};
  for (let i = 0; i < state.entries.length; i++) {
    const e = state.entries[i];
    proofs[e.address] = {
      amount: e.tokensWei.toString(),
      proof: getProof(state.layers, i),
      leaf: state.leafHashes[i]
    };
  }
  return proofs;
}

function buildEpochArtifact() {
  if (!state.entries) return null;

  const decimals = parseInt(document.getElementById("tokenDecimals").value) || 18;
  const contractAddr = document.getElementById("contractAddr").value.trim();
  const epochId = epochIdForFiles();
  const totalWei = state.entries.reduce((sum, e) => sum + e.tokensWei, 0n);

  return {
    epochId,
    merkleRoot: state.merkleRoot,
    epochUri: state.epochUri,
    tokenDecimals: decimals,
    totalTokens: ethers.formatUnits(totalWei, decimals),
    totalTokensWei: totalWei.toString(),
    recipientCount: state.entries.length,
    distributorContract: contractAddr,
    chainId: state.chainId || POLYGON_CHAIN_ID,
    publishTxHash: state.txHash || null,
    builtAt: new Date().toISOString(),
    // This is the input snapshot, including optional email.
    // Email is NOT used for merkle; it’s for notification ops.
    distribution: state.entries.map(e => ({
      address: e.address,
      tokens: e.tokensStr,
      amount: e.tokensWei.toString(),
      email: e.email || undefined
    }))
  };
}

function buildRootArtifact() {
  const epochId = epochIdForFiles();
  return {
    root: state.merkleRoot,
    epochUri: state.epochUri,
    epochId,
    distributorContract: document.getElementById("contractAddr").value.trim()
  };
}

function ensureArtifactsCached() {
  if (!state.merkleRoot || !state.entries) throw new Error("Build Merkle tree first");
  if (!state.artifacts.proofs) state.artifacts.proofs = buildProofsArtifact();
  if (!state.artifacts.epoch) state.artifacts.epoch = buildEpochArtifact();
  if (!state.artifacts.root) state.artifacts.root = buildRootArtifact();
}

/* ========================================================================
   DOWNLOADS
   ======================================================================== */
function downloadBlob(filename, blob) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

function downloadJson(filename, data) {
  const json = JSON.stringify(data, null, 2);
  const blob = new Blob([json], { type: "application/json" });
  downloadBlob(filename, blob);
}

function downloadProofs() {
  ensureArtifactsCached();
  const epochId = epochIdForFiles();
  downloadJson(`proofs.json`, state.artifacts.proofs);
}

function downloadEpochJson() {
  ensureArtifactsCached();
  downloadJson(`epoch.json`, state.artifacts.epoch);
}

function downloadRoot() {
  ensureArtifactsCached();
  downloadJson(`root.json`, state.artifacts.root);
}

async function downloadZip(isAuto) {
  ensureArtifactsCached();
  const epochId = epochIdForFiles();

  // zip contains ONLY these 3 files, named exactly:
  // proofs.json, epoch.json, root.json
  const zip = new JSZip();
  zip.file("proofs.json", JSON.stringify(state.artifacts.proofs, null, 2));
  zip.file("epoch.json", JSON.stringify(state.artifacts.epoch, null, 2));
  zip.file("root.json", JSON.stringify(state.artifacts.root, null, 2));

  const blob = await zip.generateAsync({ type: "blob" });
  const filename = `epoch-${epochId}.zip`;
  downloadBlob(filename, blob);

  // update UI label
  const autoText = document.getElementById("zipAutoText");
  if (state.publishedEpochId !== null && state.publishedEpochId !== undefined) {
    autoText.textContent = `artifacts were included in ${filename} and downloaded to your system.`;
  } else {
    autoText.textContent = `you can download epoch-${epochId}.zip now (publish will auto-download after confirmation).`;
  }

  // Keep the ZIP button label accurate
  document.getElementById("btnDlZip").textContent = (state.publishedEpochId !== null && state.publishedEpochId !== undefined)
    ? "Re-download .zip"
    : "Download as .zip";

  if (!isAuto) {
    const dlStatus = document.getElementById("downloadStatus");
    dlStatus.innerHTML = `<div class="msg-box success">✓ Downloaded ${escHtml(filename)}</div>`;
  }
}

/* ========================================================================
   NOTIFICATIONS (optional; not part of proofs zip)
   ======================================================================== */
function buildClaimLink(distributor, epoch, amountBaseUnits, proofArr) {
  const chain = state.chainId || POLYGON_CHAIN_ID;
  const base = document.getElementById("claimBaseUrl").value.trim() || "https://hmderdoc.github.io/bbs_coin_html/tx.html";
  const proofJson = JSON.stringify(proofArr);
  const proofB64 = base64UrlEncode(proofJson);
  const url = new URL(base);
  url.searchParams.set("chain", String(chain));
  url.searchParams.set("to", distributor);
  url.searchParams.set("epoch", String(epoch));
  url.searchParams.set("amount", String(amountBaseUnits));
  url.searchParams.set("proof_b64", proofB64);
  return url.toString();
}

function base64UrlEncode(str) {
  // utf-8 safe base64
  const bytes = new TextEncoder().encode(str);
  let bin = "";
  bytes.forEach(b => bin += String.fromCharCode(b));
  const b64 = btoa(bin);
  return b64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
}

function generateEmails() {
  const notifyStatus = document.getElementById("notifyStatus");
  const previewEl = document.getElementById("emailPreview");

  try {
    ensureArtifactsCached();

    const epochId = epochIdForFiles();
    if (state.publishedEpochId === null || state.publishedEpochId === undefined) {
      throw new Error("Publish an epoch first (so the epoch id + tx hash are final).");
    }

    const distributor = document.getElementById("contractAddr").value.trim();
    const tokenName = document.getElementById("notifyTokenName").value.trim() || "BBS Token";
    const tokenSymbol = document.getElementById("notifyTokenSymbol").value.trim() || "BBS";
    const fromLine = document.getElementById("notifyFromLine").value.trim() || "-- your BBS";

    const decimals = parseInt(document.getElementById("tokenDecimals").value) || 18;
    const chainId = state.chainId || POLYGON_CHAIN_ID;
    const networkName = (chainId === 137) ? "Polygon" : `Chain ${chainId}`;
    const publishTx = state.txHash || "(unknown)";

    const proofs = state.artifacts.proofs;

    const notifications = [];
    for (const e of state.entries) {
      if (!e.email) continue;

      const proofObj = proofs[e.address];
      if (!proofObj) continue;

      const amountBase = proofObj.amount; // string base units
      const amountHuman = ethers.formatUnits(BigInt(amountBase), decimals);
      const claimLink = buildClaimLink(distributor, epochId, amountBase, proofObj.proof);

      const subject = `You have ${amountHuman} ${tokenSymbol} ready to claim`;

      const body =
`You have BBS tokens ready to claim.

BBS: ${safeBbsIdGuess()}
Token: ${tokenName} (${tokenSymbol})
Network: ${networkName} (chainId ${chainId})

Claim details
-------------
Wallet: ${e.address}
Distributor: ${distributor}
Epoch: ${epochId}
Amount: ${amountHuman} ${tokenSymbol}
Amount (base units): ${amountBase}

Epoch publication
-----------------
Publish tx: ${publishTx}
Merkle root: ${state.merkleRoot}
URI: ${state.epochUri}

Claim link (MetaMask)
${claimLink}

How to claim
------------
1) Open the claim link above
2) Connect MetaMask (must be the wallet shown above)
3) Click 'Claim' and confirm the transaction

Gas fee note: You will pay a small Polygon gas fee for the claim transaction.

Security note: We will never ask for your seed phrase or private key. You only need to confirm a blockchain transaction.

If link looks suspicious, verify domain + distributor address.

${fromLine}
`;

      notifications.push({
        address: e.address,
        email: e.email,
        subject,
        body,
        filename: `claim-${epochId}-${e.address}.txt`
      });
    }

    state.notifications = notifications;

    if (notifications.length === 0) {
      previewEl.textContent = "(no emails generated — add 'email' fields in the distribution data)";
      notifyStatus.innerHTML = `<div class="msg-box warning">No email addresses found in distribution data.</div>`;
      document.getElementById("btnDlNotifyZip").disabled = true;
      updateEmailjsButtonState();
      return;
    }

    previewEl.textContent =
`To: ${notifications[0].email}
Subject: ${notifications[0].subject}

${notifications[0].body}`;

    notifyStatus.innerHTML =
      `<div class="msg-box success">✓ Generated ${notifications.length} email(s). You can download as a separate zip or send via EmailJS.</div>`;

    document.getElementById("btnDlNotifyZip").disabled = false;
    updateEmailjsButtonState();

  } catch (err) {
    notifyStatus.innerHTML = `<div class="msg-box error">${escHtml(err.message)}</div>`;
  }
}

async function downloadNotificationsZip() {
  const notifyStatus = document.getElementById("notifyStatus");
  try {
    if (!state.notifications) generateEmails();
    if (!state.notifications || state.notifications.length === 0) throw new Error("No notifications to download.");

    const epochId = epochIdForFiles();
    const zip = new JSZip();

    for (const n of state.notifications) {
      zip.file(n.filename, `To: ${n.email}\nSubject: ${n.subject}\n\n${n.body}`);
    }

    const blob = await zip.generateAsync({ type: "blob" });
    downloadBlob(`notifications-epoch-${epochId}.zip`, blob);

    notifyStatus.innerHTML = `<div class="msg-box success">✓ Downloaded notifications-epoch-${epochId}.zip</div>`;
  } catch (err) {
    notifyStatus.innerHTML = `<div class="msg-box error">${escHtml(err.message)}</div>`;
  }
}

function updateEmailjsButtonState() {
  const btn = document.getElementById("btnSendEmailjs");
  const pk = document.getElementById("emailjsPublicKey").value.trim();
  const sid = document.getElementById("emailjsServiceId").value.trim();
  const tid = document.getElementById("emailjsTemplateId").value.trim();
  btn.disabled = !(pk && sid && tid && state.notifications && state.notifications.length > 0);
}

document.getElementById("emailjsPublicKey").addEventListener("input", updateEmailjsButtonState);
document.getElementById("emailjsServiceId").addEventListener("input", updateEmailjsButtonState);
document.getElementById("emailjsTemplateId").addEventListener("input", updateEmailjsButtonState);

async function sendViaEmailJS() {
  const notifyStatus = document.getElementById("notifyStatus");
  try {
    if (!state.notifications) generateEmails();
    if (!state.notifications || state.notifications.length === 0) throw new Error("No emails to send.");

    const pk = document.getElementById("emailjsPublicKey").value.trim();
    const sid = document.getElementById("emailjsServiceId").value.trim();
    const tid = document.getElementById("emailjsTemplateId").value.trim();
    if (!pk || !sid || !tid) throw new Error("Missing EmailJS config values.");

    // Lazy-load EmailJS browser SDK (only if needed)
    if (!window.emailjs) {
      await new Promise((resolve, reject) => {
        const s = document.createElement("script");
        s.src = "https://cdn.jsdelivr.net/npm/@emailjs/browser@4/dist/email.min.js";
        s.onload = resolve;
        s.onerror = () => reject(new Error("Failed to load EmailJS SDK"));
        document.head.appendChild(s);
      });
    }

    window.emailjs.init({ publicKey: pk });

    notifyStatus.innerHTML = `<div class="msg-box info"><span class="spinner"></span>Sending ${state.notifications.length} email(s)...</div>`;

    let sent = 0;
    for (const n of state.notifications) {
      // You must set up template vars accordingly:
      // to_email, subject, message
      await window.emailjs.send(sid, tid, {
        to_email: n.email,
        subject: n.subject,
        message: n.body
      });
      sent++;
    }

    notifyStatus.innerHTML = `<div class="msg-box success">✓ Sent ${sent}/${state.notifications.length} emails via EmailJS.</div>`;
  } catch (err) {
    notifyStatus.innerHTML = `<div class="msg-box error">${escHtml(err.message)}</div>`;
  }
}

/* ========================================================================
   Helpers
   ======================================================================== */
function safeBbsIdGuess() {
  // cheap guess: use host from claimBaseUrl if it’s your board,
  // otherwise leave generic
  try {
    const u = new URL(document.getElementById("claimBaseUrl").value.trim());
    return u.hostname || "your-bbs";
  } catch {
    return "your-bbs";
  }
}
function shortAddr(addr) {
  if (!addr || addr.length < 12) return addr || "";
  return addr.substring(0, 6) + "..." + addr.substring(addr.length - 4);
}
function escHtml(s) {
  return String(s).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function statusLine(label, value, cls) {
  return `<div class="status-line"><span class="label">${escHtml(label)}: </span><span class="value ${cls || ""}">${escHtml(value)}</span></div>`;
}
function loadExample() {
  document.getElementById("inputData").value =
`[
  {"address":"0x70997970C51812dc3A010C7d01b50e0d17dc79C8","tokens":25,"email":"user1@example.com"},
  {"address":"0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC","tokens":50},
  {"address":"0x15d34AAf54267DB7D7c367839AAf71A00a2C6A65","tokens":10,"email":"user3@example.com"}
]`;
}

// Listen for account/chain changes
if (window.ethereum) {
  window.ethereum.on("accountsChanged", () => location.reload());
  window.ethereum.on("chainChanged", () => location.reload());
}
</script>

</body>
</html>
